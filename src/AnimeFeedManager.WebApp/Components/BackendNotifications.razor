@using AnimeFeedManager.WebApp.Services
@using AnimeFeedManager.WebApp.State
@using AnimeFeedManager.Common.Notifications
@inject IServerNotificationProcessingService ServerNotificationProcessingService
@inject ISnackbar Snackbar
@inject ApplicationState State
@inject INotificationService NotificationService

@code {

    [CascadingParameter]
    private Error? Error { get; set; }

    private User _lastUser = new AnonymousUser();

    protected override async Task OnInitializedAsync()
    {
        State.OnUserChanges += UserChanges;
        try
        {
            await ServerNotificationProcessingService.SubscribeToNotifications();
            ServerNotificationProcessingService.ConnectionStatus += ProcessStatusChanges;
            ServerNotificationProcessingService.SeasonProcessNotification += OnSeasonProcessNotification;
            ServerNotificationProcessingService.TitlesUpdateNotification += OnTitlesUpdateNotification;
        }
        catch (Exception e)
        {
            Error?.ProcessError("Notifications hub", e);
        }
    }

    private Task OnTitlesUpdateNotification(TitlesUpdateNotification notification)
    {
        return ProcessNotification(notification, NotificationSource.Titles);
    }
    
    private  Task OnSeasonProcessNotification(SeasonProcessNotification notification)
    {
        return ProcessNotification(notification, NotificationSource.SeasonLibrary);
    }

    private async Task ProcessNotification(RealtimeNotification notification, NotificationSource source)
    {
        switch (notification.Result)
        {
            case NotificationType.Information:
                Snackbar.Add(notification.Message, Severity.Info);
                break;
            case NotificationType.Error:
                Snackbar.Add(notification.Message, Severity.Warning);
                break;
            case NotificationType.Update:
            default:
                break;
        }

        await NotificationService.AddNotification(new ServerNotification(
            notification.Id,
            false,
            DateTime.Now,
            notification.Result,
            source,
            notification.TargetAudience,
            notification.Message
            ));
    }
   

    private async Task UserChanges(User arg)
    {
        if (arg is not AnonymousUser && _lastUser != arg)
        {
            _lastUser = arg;
            await AddToGroup(arg);
            Snackbar.Add("Added user to group", Severity.Info);
        }

        if (arg is AnonymousUser && _lastUser is not AnonymousUser)
        {
            _lastUser = arg;
            await AddToGroup(arg);
            Snackbar.Add("Removed from group", Severity.Info);
        }
    }

    private async Task AddToGroup(User user)
    {
        try
        {
            await ServerNotificationProcessingService.AddToGroup();
        }
        catch (Exception e)
        {
            Error?.ProcessError("Notifications hub", e);
        }
    }

    private async Task RemoveFromGroup(User user)
    {
        try
        {
            await ServerNotificationProcessingService.RemoveFromGroup();
        }
        catch (Exception e)
        {
            Error?.ProcessError("Notifications hub", e);
        }
    }

    private void ProcessStatusChanges(HubConnectionStatus status)
    {
        switch (status)
        {
            case HubConnectionStatus.Connected:
                Snackbar.Add("Connected to notification hub", Severity.Success);
                break;
            case HubConnectionStatus.Disconnected:
                Snackbar.Add("Notification hub connection is lost", Severity.Warning);
                break;
            case HubConnectionStatus.None:
            default:
                Snackbar.Add("Notification hub connection is in strange state", Severity.Error);
                break;
        }
    }

}