@page "/"
@page "/{Year:int}/{Season}"
@using AnimeFeedManager.WebApp.Services
@using AnimeFeedManager.WebApp.State
@using System.Collections.Immutable
@implements IDisposable
@inject ISeasonFetcherService SeasonFetcherService
@inject ISeasonCollectionFetcher SeasonCollectionFetcher
@inject ApplicationState State
@inject NavigationManager NavigationManager

<PageTitle>AFM - @GetTitle(State.Value.Season)</PageTitle>
<SeasonSelector AvailableSeasons="@_seasons" SelectedSeason="@State.Value.Season" SelectedSeasonChanged="OnSeasonChanged"></SeasonSelector>
@if (_filteredCollection is not  EmptySeasonCollection)
{
    <FilterSelector SelectedFiltersChanged="OnFilterSelectionChanges"></FilterSelector>
    <SeriesGrid Collection="@_filteredCollection"></SeriesGrid>
}

@code {
    private readonly CancellationTokenSource _cts = new ();
    private ImmutableList<SeasonInfoDto> _seasons = new List<SeasonInfoDto> { new NullSeasonInfo() }.ToImmutableList();
    private SeasonCollection _collection = new EmptySeasonCollection();
    private SeasonCollection _filteredCollection = new EmptySeasonCollection();

    [Parameter]
    public int Year { get; set; }
    
    [Parameter]
    public string Season { get; set; } = string.Empty;

    [CascadingParameter]
    private Error? Error { get; set; }

    private IEnumerable<Func<SimpleAnime, bool>> _filters = Enumerable.Empty<Func<SimpleAnime, bool>>();

    protected override async Task OnInitializedAsync()
    {
        const string key = "lo_seasons";
        State.OnStateChange += StateHasChanged;
        try
        {
            State.AddLoadingItem(key, "Loading Season");
            _seasons = await SeasonFetcherService.GetAvailableSeasons(_cts.Token);
            if (_seasons.Count > 0)
            {
                var latest = _seasons[0];
                if (latest is not NullSeasonInfo)
                {
                    State.SetSeason(latest);
                    await UpdateSeasonCollection(latest);
                }
            }
            State.RemoveLoadingItem(key);
        }
        catch (Exception e)
        {
            Error?.ProcessError("Season Fetching", e);
            State.RemoveLoadingItem(key);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        var result = DtoFactories.TryToParse(Season, Year, out var season);
        if (result)
        {
            State.SetSeason(season);
            await UpdateSeasonCollection(season);
        } else {
            NavigationManager.NavigateTo("/");
        }
    }

    private static string GetTitle(SeasonInfoDto season) =>
        season is not NullSeasonInfo ? $"{season.Year} - {season.Season.ToUpper()}" : "No Data Available";


    public void Dispose()
    {
        State.OnStateChange -= StateHasChanged;
        _cts.Cancel();
        _cts.Dispose();
    }

    private void OnSeasonChanged(SeasonInfoDto season)
    {
        NavigationManager.NavigateTo($"/{season.Year}/{season.Season}");
    }

    private async Task UpdateSeasonCollection(SeasonInfoDto season)
    {
        const string key = "lo_series";
        try
        {
            State.AddLoadingItem(key, "Loading Series");
            _collection = await SeasonCollectionFetcher.GetSeasonLibrary(season, _cts.Token);
            _filteredCollection = FilterCollection(_collection, _filters);
            State.RemoveLoadingItem(key);
        }
        catch (Exception e)
        {
            Error?.ProcessError("Season Collection Fetching", e);
            State.RemoveLoadingItem(key);
        }
    }

    private void OnFilterSelectionChanges(IEnumerable<Func<SimpleAnime, bool>> filters)
    {
        _filters = filters;
        _filteredCollection = FilterCollection(_collection, filters);
    }

    private static SeasonCollection FilterCollection(SeasonCollection collectionBase, IEnumerable<Func<SimpleAnime, bool>> filters)
    {
        return new SeasonCollection(
            collectionBase.Year,
            collectionBase.Season,
            collectionBase.Animes.Filter(filters).ToArray());
    }
}