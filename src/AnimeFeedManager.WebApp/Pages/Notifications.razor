@page "/Notifications"
@using AnimeFeedManager.WebApp.State
@using AnimeFeedManager.WebApp.Services.Notifications
@using AnimeFeedManager.WebApp.Components.Notifications
@using Microsoft.AspNetCore.Authorization
@using MudBlazor.Services
@inject ApplicationState State
@inject INotificationService NotificationService
@inject IBreakpointService BreakpointListener
@implements IAsyncDisposable
@attribute [Authorize]
<MudTabs Rounded="true" ApplyEffectsToContainer="true" Style="width: 100%" Position="_tabPosition">
    <MudTabPanel Text="TV">
        <NotificationDisplay Notifications="NotificationList.TvNotifications" For="NotificationFor.Tv"></NotificationDisplay>
    </MudTabPanel>
    <MudTabPanel Text="Ovas">
        <NotificationDisplay Notifications="NotificationList.OvasNotifications" For="NotificationFor.Ova"></NotificationDisplay>
    </MudTabPanel>
    <MudTabPanel Text="Movies">
        <NotificationDisplay Notifications="NotificationList.MoviesNotifications" For="NotificationFor.Movie"></NotificationDisplay>
    </MudTabPanel>
    @if (State.Value.User is AdminUser)
    {
        <MudTabPanel Text="Images">
            <NotificationDisplay Notifications="NotificationList.ImagesNotifications" For="NotificationFor.Images"></NotificationDisplay>
        </MudTabPanel>
        <MudTabPanel Text="Admin">
            <NotificationDisplay Notifications="NotificationList.AdminNotifications" For="NotificationFor.Admin"></NotificationDisplay>
        </MudTabPanel>
    }
</MudTabs>

@code {
    private readonly CancellationTokenSource _cts = new();

    [CascadingParameter]
    private Error? Error { get; set; }

    private UiNotifications NotificationList { get; set; } = new EmptyUiNotifications();
    private Position _tabPosition = Position.Bottom;
    private Guid? _subscriptionId;

    protected override async Task OnInitializedAsync()
    {
        State.OnStateChange += StateHasChanged;
        State.OnUserChanges += OnUserChanges;
        _tabPosition = GetPosition(await BreakpointListener.GetBreakpoint());
            await OnUserChanges(State.Value.User);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var subscriptionResult = await BreakpointListener.Subscribe((breakpoint) =>
            {
                _tabPosition = GetPosition(breakpoint);
                InvokeAsync(StateHasChanged);
            }, new ResizeOptions
            {
                ReportRate = 250,
                NotifyOnBreakpointOnly = true,
            });

            _subscriptionId = subscriptionResult.SubscriptionId;
            StateHasChanged();
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task OnUserChanges(User user)
    {
        if (user is ApplicationUser u)
            await GetNotifications(u.Email);
    }

    private static Position GetPosition(Breakpoint breakpoint) => breakpoint is Breakpoint.Xs ? Position.Top : Position.Left;


    private async Task GetNotifications(string user)
    {
        try
        {
            NotificationList = await NotificationService.GetNotifications(user, _cts.Token);
        }
        catch (Exception e)
        {
            Error?.ProcessError("Getting Notification", e);
        }
    }

    public async ValueTask DisposeAsync()
    {
        State.OnStateChange -= StateHasChanged;
        _cts.Cancel();
        _cts.Dispose();
        if (_subscriptionId is not null)
            await BreakpointListener.Unsubscribe(_subscriptionId.Value);
    }
    
}